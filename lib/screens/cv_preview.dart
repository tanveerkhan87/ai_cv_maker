// Imports for Mobile-specific functionality (File I/O)
import 'dart:io';

import 'package:flutter/foundation.dart'; // Provides 'kIsWeb' to detect if running on web
import 'package:flutter/material.dart';

// Imports for PDF Generation
import 'package:pdf/widgets.dart' as pw; // Using 'as pw' to avoid name conflicts with Flutter's widgets
import 'package:pdf/pdf.dart';

// Imports for handling file system on mobile
import 'package:path_provider/path_provider.dart'; // To find the correct directory to save files
import 'package:open_file/open_file.dart'; // To open the saved PDF file

// Imports for Web-specific functionality (to trigger download in a browser)
import 'package:universal_html/html.dart' as html;

import 'package:flutter_gemini/flutter_gemini.dart';


class CVPreviewScreen extends StatefulWidget {
  // These are the final properties that hold the user's input from the previous screen.
  final String name, jobTitle, email, phone, experience, education, skills;

  // The constructor receives the user's data and assigns it to the final properties.
  CVPreviewScreen({
    required this.name,
    required this.jobTitle,
    required this.email,
    required this.phone,
    required this.experience,
    required this.education,
    required this.skills,
  });

  @override
  _CVPreviewScreenState createState() => _CVPreviewScreenState();
}

class _CVPreviewScreenState extends State<CVPreviewScreen> {
  // The client instance used to communicate with the Gemini AI API.
  late Gemini gemini;

  bool _isGenerating = false;

  //  A string to hold the CV summary generated by the AI.
  String _aiGeneratedContent = "Generating AI CV...";

  // `initState` runs once when the widget is first created.
  /// It's the perfect place to do initial setup, like initializing the API client
  /// and kicking off the first data fetch.
  @override
  void initState() {
    super.initState();
    // Initialize the Gemini client with your API key.
    gemini = Gemini.init(apiKey: "123"); // IMPORTANT: Replace with your actual API key

    // Immediately start fetching the AI-generated content.
    _fetchAICVContent();
  }

  // Asynchronously fetches the CV summary from the Gemini API.
  Future<void> _fetchAICVContent() async {
    // Set state to true to show the loading indicator to the user.
    setState(() => _isGenerating = true);

    String prompt = """
    Generate an elite, professionally structured CV summary based on the following user details:
    **User Details:**  
    - **Full Name:** ${widget.name}  
    - **Job Title:** ${widget.jobTitle}  
    - **Experience:** ${widget.experience}  
    - **Education:** ${widget.education}  
    - **Skills:** ${widget.skills}  

    **Strict Rules:**  
    - The summary should be professional and polished.  
    - DO NOT repeat or include the email or phone number.  
    - No extra details beyond the provided information.  
    """;

    // This is the actual network call to the Gemini API. The `await` keyword
    // pauses the function until the AI sends back a response.
    final response = await gemini.text(prompt);

    // After getting the response, update the state again.
    setState(() {
      // Store the AI's output. If the response is null or fails, show an error message.
      _aiGeneratedContent = response?.output ?? "Error: AI failed to generate content.";
      // Set generating to false to hide the loading indicator.
      _isGenerating = false;
    });
  }

  /// Creates a PDF document and then saves or opens it.
  Future<void> _saveAndOpenPDF() async {
    // 1. --- PDF Document Creation ---
    final pdf = pw.Document();

    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (pw.Context context) {
          // This is where you would ideally use the `_aiGeneratedContent` from the state.
          // For example, in the "PROFESSIONAL SUMMARY" section.
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              // Header Section
              pw.Center(child: pw.Text(widget.name.toUpperCase(), style: pw.TextStyle(fontSize: 28, fontWeight: pw.FontWeight.bold))),
              pw.SizedBox(height: 20),

              // AI-Generated Professional Summary
              pw.Text("PROFESSIONAL SUMMARY", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
              pw.Divider(),
              // Here we insert the content generated by the AI!
              pw.Text(_aiGeneratedContent, style: pw.TextStyle(fontSize: 12, fontStyle: pw.FontStyle.italic)),
              pw.SizedBox(height: 15),

              // Other sections using the user-provided data from `widget`.
              pw.Text("WORK EXPERIENCE", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
              pw.Divider(),
              pw.Text(widget.experience),
              pw.SizedBox(height: 15),

              pw.Text("EDUCATION", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
              pw.Divider(),
              pw.Text(widget.education),
              pw.SizedBox(height: 15),

              pw.Text("SKILLS", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
              pw.Divider(),
              pw.Text(widget.skills),
            ],
          );
        },
      ),
    );

    // 2. --- Platform-Specific Saving/Opening Logic ---
    // This is a critical concept for multi-platform apps. The way you handle files
    // is completely different on web vs. mobile.

    // If the app is running in a web browser:
    if (kIsWeb) {
      // Use the 'universal_html' package to trigger a download in the browser.
      final blob = html.Blob([await pdf.save()]); // Create a web-compatible file object.
      final url = html.Url.createObjectUrlFromBlob(blob); // Create a temporary URL for it.
      final anchor = html.AnchorElement(href: url) // Create an invisible link element.
        ..setAttribute("download", "CV_${widget.name.replaceAll(' ', '_')}.pdf") // Set the download filename.
        ..click(); // Programmatically click the link to start the download.
      html.Url.revokeObjectUrl(url); // Clean up the temporary URL.
    }
    // If the app is running on a mobile device (iOS/Android):
    else {
      final directory = await getApplicationDocumentsDirectory(); // Get the app's private document folder.
      final filePath = '${directory.path}/CV_${widget.name.replaceAll(' ', '_')}.pdf';
      final file = File(filePath);
      await file.writeAsBytes(await pdf.save()); // Save the PDF bytes to the file.
      await OpenFile.open(filePath); // Ask the OS to open the file with a PDF viewer.
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Elite CV Generator")),
      body: Center(

        child: _isGenerating
            ? CircularProgressIndicator()
            : ElevatedButton(
          onPressed: _saveAndOpenPDF,
          child: Text("Download Elite CV"),
        ),
      ),
    );
  }
}
